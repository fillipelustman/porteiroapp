<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Interfone - Apartamentos</title>
    <!-- Supabase SDK -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #e9ecef;
        }

        .panel h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #229954;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.calling {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .apartment-info {
            background: #e8f4f8;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .residents-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .resident-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .resident-item.online {
            border-left-color: #27ae60;
        }

        .resident-item.offline {
            border-left-color: #e74c3c;
        }

        .resident-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 12px;
            color: white;
        }

        .resident-status.online {
            background: #27ae60;
        }

        .resident-status.offline {
            background: #e74c3c;
        }

        .call-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }

        .call-info.active {
            display: block;
        }

        .logs {
            grid-column: 1 / -1;
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .logs h3 {
            margin-bottom: 15px;
            color: #ecf0f1;
        }

        .log-container {
            background: #34495e;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }

        .log-entry.info {
            color: #3498db;
        }

        .log-entry.success {
            color: #27ae60;
        }

        .log-entry.error {
            color: #e74c3c;
        }

        .search-container {
            display: flex;
            gap: 10px;
            align-items: end;
        }

        .search-container input {
            flex: 1;
        }

        .search-container button {
            flex-shrink: 0;
        }

        /* Estilos para teste WebRTC real */
        .webrtc-test-panel {
            grid-column: 1 / -1;
            background: #e8f5e8;
            border: 2px solid #27ae60;
            margin-top: 20px;
        }

        .webrtc-test-panel h3 {
            color: #27ae60;
            border-bottom-color: #27ae60;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            font-weight: 600;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .connection-status.connecting {
            background: #fff3cd;
            color: #856404;
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-status.failed {
            background: #f8d7da;
            color: #721c24;
        }

        .audio-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background: #f1f3f4;
            border-radius: 8px;
        }

        .volume-meter {
            flex: 1;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .volume-bar {
            height: 100%;
            background: linear-gradient(90deg, #27ae60 0%, #f39c12 70%, #e74c3c 100%);
            width: 0%;
            transition: width 0.1s ease;
        }

        .volume-label {
            font-size: 12px;
            font-weight: 600;
            color: #2c3e50;
            min-width: 80px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .btn-test {
            background: #17a2b8;
            color: white;
        }

        .btn-test:hover:not(:disabled) {
            background: #138496;
        }

        .ice-candidates {
            max-height: 150px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .ice-candidate {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .ice-candidate.host {
            background: #d4edda;
        }

        .ice-candidate.srflx {
            background: #fff3cd;
        }

        .ice-candidate.relay {
            background: #f8d7da;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè¢ Sistema de Interfone - Apartamentos</h1>
            <p>Interface integrada com Supabase para chamadas por apartamento</p>
        </div>

        <div class="main-content">
            <!-- Painel do Interfone -->
            <div class="panel">
                <h3>üìû Painel do Interfone</h3>
                
                <div class="form-group">
                    <label>Pr√©dio:</label>
                    <select id="buildingSelect">
                        <option value="">Carregando pr√©dios...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>N√∫mero do Apartamento:</label>
                    <div class="search-container">
                        <input type="text" id="apartmentNumber" placeholder="Ex: 101, 202, 1503">
                        <button class="btn btn-primary" onclick="searchApartment()">üîç Buscar</button>
                    </div>
                </div>

                <div class="apartment-info" id="apartmentInfo" style="display: none;">
                    <h4>üìç Informa√ß√µes do Apartamento</h4>
                    <div id="apartmentDetails"></div>
                    
                    <label>Moradores do Apartamento:</label>
                    <div class="residents-list" id="residentsList">
                        <div style="text-align: center; color: #6c757d;">
                            Selecione um pr√©dio e digite o n√∫mero do apartamento
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Nome do Visitante:</label>
                    <input type="text" id="visitorName" value="Visitante" placeholder="Nome de quem est√° visitando">
                </div>

                <div class="status" id="interfoneStatus">Aguardando sele√ß√£o de apartamento</div>

                <div style="text-align: center;">
                    <button class="btn btn-primary" id="callApartmentBtn" onclick="callApartment()" disabled>
                        üìû Chamar Apartamento
                    </button>
                    <button class="btn btn-danger" id="endCallBtn" onclick="endCall()" disabled>
                        üì¥ Encerrar Chamada
                    </button>
                </div>

                <div class="call-info" id="callInfo">
                    <h4>üìû Chamada em Andamento</h4>
                    <div id="callDetails"></div>
                </div>
            </div>

            <!-- Painel de Simula√ß√£o do Morador -->
            <div class="panel">
                <h3>üè† Simula√ß√£o do Morador</h3>
                
                <div class="form-group">
                    <label>Simular como Morador:</label>
                    <select id="residentSimulator">
                        <option value="">Selecione um morador</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Status do Morador:</label>
                    <div style="text-align: center;">
                        <button class="btn btn-success" onclick="setResidentStatus('online')">üü¢ Online</button>
                        <button class="btn btn-danger" onclick="setResidentStatus('offline')">üî¥ Offline</button>
                    </div>
                </div>

                <div class="status" id="residentStatus">Aguardando configura√ß√£o</div>

                <div style="text-align: center;">
                    <button class="btn btn-success" id="answerCallBtn" onclick="answerCall()" disabled>
                        ‚úÖ Atender Chamada
                    </button>
                    <button class="btn btn-danger" id="rejectCallBtn" onclick="rejectCall()" disabled>
                        ‚ùå Rejeitar Chamada
                    </button>
                </div>

                <div class="call-info" id="residentCallInfo">
                    <h4>üìû Chamada Recebida</h4>
                    <div id="residentCallDetails"></div>
                </div>
            </div>

            <!-- Painel de Teste WebRTC Real -->
            <div class="panel webrtc-test-panel">
                <h3>üîß Teste de Conex√£o WebRTC Real</h3>
                
                <div class="connection-status disconnected" id="webrtcStatus">
                    <span>üî¥</span>
                    <span>Desconectado - Clique em "Iniciar Teste WebRTC" para come√ßar</span>
                </div>

                <div class="test-controls">
                    <button class="btn btn-test" id="startWebRTCTest" onclick="startWebRTCTest()">
                        üöÄ Iniciar Teste WebRTC
                    </button>
                    <button class="btn btn-test" id="testMicrophone" onclick="testMicrophone()">
                        üé§ Testar Microfone
                    </button>
                    <button class="btn btn-danger" id="stopWebRTCTest" onclick="stopWebRTCTest()" disabled>
                        ‚èπÔ∏è Parar Teste
                    </button>
                </div>

                <div class="audio-controls" id="audioControls" style="display: none;">
                    <div class="volume-label">Porteiro:</div>
                    <div class="volume-meter">
                        <div class="volume-bar" id="doormanVolumeBar"></div>
                    </div>
                    <button class="btn btn-secondary" id="muteDoorman" onclick="toggleMute('doorman')">üîá</button>
                </div>

                <div class="audio-controls" id="residentAudioControls" style="display: none;">
                    <div class="volume-label">Morador:</div>
                    <div class="volume-meter">
                        <div class="volume-bar" id="residentVolumeBar"></div>
                    </div>
                    <button class="btn btn-secondary" id="muteResident" onclick="toggleMute('resident')">üîá</button>
                </div>

                <div class="stats-grid" id="connectionStats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-label">Estado da Conex√£o</div>
                        <div class="stat-value" id="connectionState">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ICE Connection State</div>
                        <div class="stat-value" id="iceConnectionState">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Lat√™ncia (ms)</div>
                        <div class="stat-value" id="latency">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Bitrate (kbps)</div>
                        <div class="stat-value" id="bitrate">-</div>
                    </div>
                </div>

                <div id="iceCandidatesSection" style="display: none;">
                    <h4>ICE Candidates:</h4>
                    <div class="ice-candidates" id="iceCandidates"></div>
                </div>
            </div>

            <!-- Logs -->
            <div class="logs">
                <h3>üìã Logs do Sistema</h3>
                <div class="log-container" id="logContainer">
                    <div class="log-entry info">üöÄ Carregando sistema de interfone...</div>
                    <div class="log-entry info">üì° Conectando com Supabase...</div>
                    <div class="log-entry info">üè¢ Carregando dados dos pr√©dios...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√µes do Supabase
        const SUPABASE_URL = 'https://ycamhxzumzkpxuhtugxc.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InljYW1oeHp1bXprcHh1aHR1Z3hjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3MjEwMzEsImV4cCI6MjA3MTI5NzAzMX0.CBgkeAVbxlyJHftmVWSkSPefrbOdMckMvtakRTDpgc8';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Mock do WebRTCService para teste da interface
        class WebRTCService {
            constructor() {
                this.supabase = supabase;
            }

            async getBuildings() {
                try {
                    const { data, error } = await this.supabase
                        .from('buildings')
                        .select('*')
                        .order('name');
                    
                    if (error) throw error;
                    return data || [];
                } catch (error) {
                    console.error('Erro ao buscar pr√©dios:', error);
                    // Retornar dados mock para teste
                    return [
                        { id: 'building-1', name: 'Edif√≠cio Teste A' },
                        { id: 'building-2', name: 'Edif√≠cio Teste B' }
                    ];
                }
            }

            async getBuildingApartments(buildingId) {
                try {
                    const { data, error } = await this.supabase
                        .from('apartments')
                        .select('*')
                        .eq('building_id', buildingId)
                        .order('number');
                    
                    if (error) throw error;
                    return data || [];
                } catch (error) {
                    console.error('Erro ao buscar apartamentos:', error);
                    // Retornar dados mock para teste
                    return [
                        { id: 'apt-101', building_id: buildingId, number: '101', floor: 1 },
                        { id: 'apt-102', building_id: buildingId, number: '102', floor: 1 },
                        { id: 'apt-201', building_id: buildingId, number: '201', floor: 2 }
                    ];
                }
            }

            async getApartmentResidents(apartmentId) {
                try {
                    const { data, error } = await this.supabase
                        .rpc('get_apartment_residents', { apartment_id: apartmentId });
                    
                    if (error) throw error;
                    return data || [];
                } catch (error) {
                    console.error('Erro ao buscar moradores:', error);
                    // Retornar dados mock para teste
                    return [
                        {
                            profile_id: 'profile-1',
                            full_name: 'Maria Silva',
                            is_primary: true,
                            is_owner: true,
                            relationship: 'owner',
                            is_online: true
                        },
                        {
                            profile_id: 'profile-2',
                            full_name: 'Jo√£o Silva',
                            is_primary: false,
                            is_owner: false,
                            relationship: 'family_member',
                            is_online: false
                        }
                    ];
                }
            }

            async initiateApartmentCall(buildingId, apartmentNumber, visitorName) {
                try {
                    // Simular chamada para apartamento
                    console.log('Iniciando chamada para:', { buildingId, apartmentNumber, visitorName });
                    
                    // Simular sucesso
                    return {
                        success: true,
                        call: {
                            id: 'call-' + Date.now(),
                            building_id: buildingId,
                            apartment_number: apartmentNumber,
                            visitor_name: visitorName,
                            status: 'calling'
                        }
                    };
                } catch (error) {
                    console.error('Erro ao iniciar chamada:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
        }

        // Vari√°veis globais
        let webrtcService;
        let buildings = [];
        let apartments = [];
        let currentApartmentResidents = [];
        let selectedResident = null;
        let activeCalls = [];
        let currentApartment = null;

        // Inicializa√ß√£o do sistema
        async function initializeSystem() {
            try {
                log('üöÄ Inicializando sistema de interfone...', 'info');
                
                // Inicializar WebRTC Service
                webrtcService = new WebRTCService();
                
                // Carregar pr√©dios
                await loadBuildings();
                
                // Configurar event listeners
                setupEventListeners();
                
                log('‚úÖ Sistema inicializado com sucesso', 'success');
                
            } catch (error) {
                console.error('Erro na inicializa√ß√£o:', error);
                log(`‚ùå Erro na inicializa√ß√£o: ${error.message}`, 'error');
            }
        }

        // Carregar pr√©dios do banco
        async function loadBuildings() {
            try {
                log('üè¢ Carregando pr√©dios...', 'info');
                
                buildings = await webrtcService.getBuildings();
                
                const buildingSelect = document.getElementById('buildingSelect');
                buildingSelect.innerHTML = '<option value="">Selecione um pr√©dio</option>';
                
                buildings.forEach(building => {
                    const option = document.createElement('option');
                    option.value = building.id;
                    option.textContent = building.name;
                    buildingSelect.appendChild(option);
                });
                
                log(`‚úÖ ${buildings.length} pr√©dios carregados`, 'success');
                
            } catch (error) {
                console.error('Erro ao carregar pr√©dios:', error);
                log(`‚ùå Erro ao carregar pr√©dios: ${error.message}`, 'error');
            }
        }

        // Buscar apartamento
        async function searchApartment() {
            const buildingId = document.getElementById('buildingSelect').value;
            const apartmentNumber = document.getElementById('apartmentNumber').value.trim();
            
            if (!buildingId) {
                log('‚ö†Ô∏è Selecione um pr√©dio primeiro', 'error');
                return;
            }
            
            if (!apartmentNumber) {
                log('‚ö†Ô∏è Digite o n√∫mero do apartamento', 'error');
                return;
            }
            
            try {
                log(`üîç Buscando apartamento ${apartmentNumber}...`, 'info');
                
                // Buscar apartamentos do pr√©dio
                apartments = await webrtcService.getBuildingApartments(buildingId);
                
                // Encontrar o apartamento espec√≠fico
                const apartment = apartments.find(apt => apt.number === apartmentNumber);
                
                if (!apartment) {
                    log(`‚ùå Apartamento ${apartmentNumber} n√£o encontrado`, 'error');
                    clearApartmentInfo();
                    return;
                }
                
                currentApartment = apartment;
                
                // Buscar moradores do apartamento
                currentApartmentResidents = await webrtcService.getApartmentResidents(apartment.id);
                
                // Exibir informa√ß√µes
                displayApartmentInfo(apartment, currentApartmentResidents);
                
                log(`‚úÖ Apartamento ${apartmentNumber} encontrado com ${currentApartmentResidents.length} moradores`, 'success');
                
            } catch (error) {
                console.error('Erro ao buscar apartamento:', error);
                log(`‚ùå Erro ao buscar apartamento: ${error.message}`, 'error');
            }
        }

        // Exibir informa√ß√µes do apartamento
        function displayApartmentInfo(apartment, residents) {
            const apartmentInfo = document.getElementById('apartmentInfo');
            const apartmentDetails = document.getElementById('apartmentDetails');
            const residentsList = document.getElementById('residentsList');
            const residentSimulator = document.getElementById('residentSimulator');
            
            // Mostrar informa√ß√µes do apartamento
            apartmentDetails.innerHTML = `
                <p><strong>N√∫mero:</strong> ${apartment.number}</p>
                <p><strong>Andar:</strong> ${apartment.floor || 'N/A'}</p>
            `;
            
            // Mostrar moradores
            if (residents.length === 0) {
                residentsList.innerHTML = '<div style="text-align: center; color: #6c757d;">Nenhum morador cadastrado</div>';
            } else {
                residentsList.innerHTML = residents.map(resident => `
                    <div class="resident-item ${resident.is_online ? 'online' : 'offline'}">
                        <div>
                            <strong>${resident.full_name}</strong>
                            <br>
                            <small>${resident.relationship}${resident.is_primary ? ' (Principal)' : ''}${resident.is_owner ? ' (Propriet√°rio)' : ''}</small>
                        </div>
                        <span class="resident-status ${resident.is_online ? 'online' : 'offline'}">
                            ${resident.is_online ? 'Online' : 'Offline'}
                        </span>
                    </div>
                `).join('');
            }
            
            // Atualizar simulador de morador
            residentSimulator.innerHTML = '<option value="">Selecione um morador</option>' +
                residents.map(resident => `
                    <option value="${resident.profile_id}">${resident.full_name}</option>
                `).join('');
            
            apartmentInfo.style.display = 'block';
            
            // Habilitar bot√£o de chamada
            document.getElementById('callApartmentBtn').disabled = false;
            document.getElementById('interfoneStatus').textContent = `Pronto para chamar apartamento ${apartment.number}`;
            document.getElementById('interfoneStatus').className = 'status connected';
        }

        // Limpar informa√ß√µes do apartamento
        function clearApartmentInfo() {
            document.getElementById('apartmentInfo').style.display = 'none';
            document.getElementById('callApartmentBtn').disabled = true;
            document.getElementById('interfoneStatus').textContent = 'Aguardando sele√ß√£o de apartamento';
            document.getElementById('interfoneStatus').className = 'status';
            currentApartment = null;
            currentApartmentResidents = [];
        }

        // Chamar apartamento
        async function callApartment() {
            if (!currentApartment) {
                log('‚ùå Nenhum apartamento selecionado', 'error');
                return;
            }
            
            const visitorName = document.getElementById('visitorName').value.trim() || 'Visitante';
            
            try {
                log(`üìû Chamando apartamento ${currentApartment.number}...`, 'info');
                
                const result = await webrtcService.initiateApartmentCall(
                    currentApartment.building_id,
                    currentApartment.number,
                    visitorName
                );
                
                if (result.success) {
                    activeCalls.push(result.call);
                    displayCallInfo(result.call);
                    
                    // Atualizar interface
                    document.getElementById('callApartmentBtn').disabled = true;
                    document.getElementById('endCallBtn').disabled = false;
                    document.getElementById('interfoneStatus').textContent = `Chamando apartamento ${currentApartment.number}...`;
                    document.getElementById('interfoneStatus').className = 'status calling';
                    
                    // Habilitar bot√µes do morador se um estiver selecionado
                    const selectedResidentId = document.getElementById('residentSimulator').value;
                    if (selectedResidentId) {
                        document.getElementById('answerCallBtn').disabled = false;
                        document.getElementById('rejectCallBtn').disabled = false;
                    }
                    
                    log(`‚úÖ Chamada iniciada para apartamento ${currentApartment.number}`, 'success');
                } else {
                    log(`‚ùå Erro ao iniciar chamada: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Erro ao chamar apartamento:', error);
                log(`‚ùå Erro ao chamar apartamento: ${error.message}`, 'error');
            }
        }

        // Exibir informa√ß√µes da chamada
        function displayCallInfo(call) {
            const callInfo = document.getElementById('callInfo');
            const callDetails = document.getElementById('callDetails');
            
            callDetails.innerHTML = `
                <p><strong>Apartamento:</strong> ${call.apartment_number}</p>
                <p><strong>Visitante:</strong> ${call.visitor_name}</p>
                <p><strong>Status:</strong> ${call.status}</p>
                <p><strong>Hor√°rio:</strong> ${new Date().toLocaleTimeString()}</p>
            `;
            
            callInfo.classList.add('active');
        }

        // Encerrar chamada
        function endCall() {
            try {
                log('üì¥ Encerrando chamada...', 'info');
                
                // Limpar chamadas ativas
                activeCalls = [];
                
                // Atualizar interface
                document.getElementById('callApartmentBtn').disabled = false;
                document.getElementById('endCallBtn').disabled = true;
                document.getElementById('answerCallBtn').disabled = true;
                document.getElementById('rejectCallBtn').disabled = true;
                
                document.getElementById('interfoneStatus').textContent = `Pronto para chamar apartamento ${currentApartment?.number || ''}`;
                document.getElementById('interfoneStatus').className = 'status connected';
                
                document.getElementById('residentStatus').textContent = 'Aguardando configura√ß√£o';
                document.getElementById('residentStatus').className = 'status';
                
                // Ocultar informa√ß√µes da chamada
                document.getElementById('callInfo').classList.remove('active');
                document.getElementById('residentCallInfo').classList.remove('active');
                
                log('‚úÖ Chamada encerrada', 'success');
                
            } catch (error) {
                console.error('Erro ao encerrar chamada:', error);
                log(`‚ùå Erro ao encerrar chamada: ${error.message}`, 'error');
            }
        }

        // Configurar simulador de morador
        function setupResidentSimulator() {
            const residentSimulator = document.getElementById('residentSimulator');
            
            residentSimulator.addEventListener('change', function() {
                const selectedId = this.value;
                if (selectedId) {
                    selectedResident = currentApartmentResidents.find(r => r.profile_id === selectedId);
                    if (selectedResident) {
                        log(`üë§ Simulando como: ${selectedResident.full_name}`, 'info');
                        document.getElementById('residentStatus').textContent = `Simulando: ${selectedResident.full_name}`;
                        document.getElementById('residentStatus').className = 'status connected';
                    }
                } else {
                    selectedResident = null;
                    document.getElementById('residentStatus').textContent = 'Aguardando configura√ß√£o';
                    document.getElementById('residentStatus').className = 'status';
                }
            });
        }

        // Definir status do morador
        function setResidentStatus(status) {
            if (!selectedResident) {
                log('‚ö†Ô∏è Selecione um morador primeiro', 'error');
                return;
            }
            
            selectedResident.is_online = (status === 'online');
            
            log(`${status === 'online' ? 'üü¢' : 'üî¥'} ${selectedResident.full_name} est√° ${status === 'online' ? 'online' : 'offline'}`, 'info');
            
            // Atualizar a lista de moradores
            if (currentApartment) {
                displayApartmentInfo(currentApartment, currentApartmentResidents);
            }
        }

        // Atender chamada
        function answerCall() {
            if (!selectedResident) {
                log('‚ö†Ô∏è Selecione um morador primeiro', 'error');
                return;
            }
            
            if (activeCalls.length === 0) {
                log('‚ö†Ô∏è Nenhuma chamada ativa', 'error');
                return;
            }
            
            log(`‚úÖ ${selectedResident.full_name} atendeu a chamada`, 'success');
            
            // Atualizar interface
            document.getElementById('answerCallBtn').disabled = true;
            document.getElementById('rejectCallBtn').disabled = true;
            document.getElementById('residentStatus').textContent = `${selectedResident.full_name} - Em chamada`;
            document.getElementById('residentStatus').className = 'status connected';
            
            // Mostrar informa√ß√µes da chamada para o morador
            const residentCallInfo = document.getElementById('residentCallInfo');
            const residentCallDetails = document.getElementById('residentCallDetails');
            
            residentCallDetails.innerHTML = `
                <p><strong>Visitante:</strong> ${activeCalls[0].visitor_name}</p>
                <p><strong>Apartamento:</strong> ${activeCalls[0].apartment_number}</p>
                <p><strong>Status:</strong> Chamada atendida</p>
            `;
            
            residentCallInfo.classList.add('active');
        }

        // Rejeitar chamada
        function rejectCall() {
            if (!selectedResident) {
                log('‚ö†Ô∏è Selecione um morador primeiro', 'error');
                return;
            }
            
            if (activeCalls.length === 0) {
                log('‚ö†Ô∏è Nenhuma chamada ativa', 'error');
                return;
            }
            
            log(`‚ùå ${selectedResident.full_name} rejeitou a chamada`, 'info');
            
            // Encerrar chamada
            endCall();
        }

        // Configurar event listeners
        function setupEventListeners() {
            setupResidentSimulator();
        }

        // Fun√ß√£o de log
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ===== SISTEMA DE TESTE WEBRTC REAL =====
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let isWebRTCActive = false;
        let audioContext = null;
        let analyser = null;
        let volumeInterval = null;
        let statsInterval = null;

        // Configura√ß√£o WebRTC
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Iniciar teste WebRTC
        async function startWebRTCTest() {
            try {
                log('üöÄ Iniciando teste WebRTC real...', 'info');
                updateWebRTCStatus('connecting', 'üü° Conectando - Solicitando permiss√£o do microfone...');
                
                // Solicitar permiss√£o do microfone
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                log('‚úÖ Microfone capturado com sucesso', 'success');
                
                // Criar peer connection
                peerConnection = new RTCPeerConnection(rtcConfiguration);
                
                // Adicionar stream local
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Configurar eventos
                setupPeerConnectionEvents();
                
                // Inicializar an√°lise de √°udio
                setupAudioAnalysis();
                
                // Simular conex√£o local (para teste)
                await createOffer();
                
                isWebRTCActive = true;
                document.getElementById('startWebRTCTest').disabled = true;
                document.getElementById('stopWebRTCTest').disabled = false;
                document.getElementById('audioControls').style.display = 'block';
                document.getElementById('connectionStats').style.display = 'block';
                document.getElementById('iceCandidatesSection').style.display = 'block';
                
                updateWebRTCStatus('connected', 'üü¢ Conectado - Teste WebRTC ativo');
                log('üéâ Teste WebRTC iniciado com sucesso!', 'success');
                
            } catch (error) {
                log(`‚ùå Erro ao iniciar WebRTC: ${error.message}`, 'error');
                updateWebRTCStatus('failed', 'üî¥ Falha - Erro ao conectar');
                console.error('WebRTC Error:', error);
            }
        }

        // Configurar eventos do peer connection
        function setupPeerConnectionEvents() {
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    log(`üßä ICE Candidate: ${event.candidate.type}`, 'info');
                    addICECandidate(event.candidate);
                }
            };
            
            peerConnection.ontrack = (event) => {
                log('üéµ Stream remoto recebido', 'success');
                remoteStream = event.streams[0];
                
                // Criar elemento de √°udio para reproduzir o stream remoto
                const audioElement = document.createElement('audio');
                audioElement.srcObject = remoteStream;
                audioElement.autoplay = true;
                audioElement.volume = 0.8;
                document.body.appendChild(audioElement);
            };
            
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                log(`üîó Estado da conex√£o: ${state}`, 'info');
                document.getElementById('connectionState').textContent = state;
                
                if (state === 'connected') {
                    updateWebRTCStatus('connected', 'üü¢ Conectado - √Åudio funcionando');
                    startStatsMonitoring();
                } else if (state === 'failed' || state === 'disconnected') {
                    updateWebRTCStatus('failed', 'üî¥ Falha - Conex√£o perdida');
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                log(`‚ùÑÔ∏è ICE Connection State: ${state}`, 'info');
                document.getElementById('iceConnectionState').textContent = state;
            };
        }

        // Configurar an√°lise de √°udio
        function setupAudioAnalysis() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(localStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                // Iniciar monitoramento de volume
                startVolumeMonitoring();
                
            } catch (error) {
                log(`‚ö†Ô∏è Erro na an√°lise de √°udio: ${error.message}`, 'warning');
            }
        }

        // Monitorar volume
        function startVolumeMonitoring() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            volumeInterval = setInterval(() => {
                if (!analyser) return;
                
                analyser.getByteFrequencyData(dataArray);
                
                // Calcular volume m√©dio
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const volume = (average / 255) * 100;
                
                // Atualizar barra de volume
                const volumeBar = document.getElementById('doormanVolumeBar');
                if (volumeBar) {
                    volumeBar.style.width = `${volume}%`;
                    volumeBar.style.backgroundColor = volume > 50 ? '#4CAF50' : volume > 20 ? '#FFC107' : '#f44336';
                }
                
            }, 100);
        }

        // Criar oferta
        async function createOffer() {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                log('üì§ Oferta criada e definida', 'info');
                
                // Simular resposta (para teste local)
                setTimeout(async () => {
                    await simulateAnswer(offer);
                }, 1000);
                
            } catch (error) {
                log(`‚ùå Erro ao criar oferta: ${error.message}`, 'error');
            }
        }

        // Simular resposta (para teste local)
        async function simulateAnswer(offer) {
            try {
                // Criar segundo peer connection para simular o morador
                const remotePeer = new RTCPeerConnection(rtcConfiguration);
                
                // Configurar stream remoto (sil√™ncio para teste)
                const silentStream = await createSilentAudioStream();
                silentStream.getTracks().forEach(track => {
                    remotePeer.addTrack(track, silentStream);
                });
                
                await remotePeer.setRemoteDescription(offer);
                const answer = await remotePeer.createAnswer();
                await remotePeer.setLocalDescription(answer);
                
                // Aplicar resposta no peer principal
                await peerConnection.setRemoteDescription(answer);
                
                log('üì• Resposta simulada aplicada', 'success');
                
            } catch (error) {
                log(`‚ùå Erro na simula√ß√£o: ${error.message}`, 'error');
            }
        }

        // Criar stream de √°udio silencioso
        async function createSilentAudioStream() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.value = 0; // Sil√™ncio
            
            const stream = audioContext.createMediaStreamDestination().stream;
            return stream;
        }

        // Monitorar estat√≠sticas
        function startStatsMonitoring() {
            statsInterval = setInterval(async () => {
                if (!peerConnection) return;
                
                try {
                    const stats = await peerConnection.getStats();
                    let latency = 0;
                    let bitrate = 0;
                    
                    stats.forEach(report => {
                        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                            latency = report.currentRoundTripTime ? Math.round(report.currentRoundTripTime * 1000) : 0;
                        }
                        if (report.type === 'inbound-rtp' && report.mediaType === 'audio') {
                            bitrate = report.bytesReceived ? Math.round(report.bytesReceived * 8 / 1000) : 0;
                        }
                    });
                    
                    document.getElementById('latency').textContent = latency > 0 ? `${latency}ms` : '-';
                    document.getElementById('bitrate').textContent = bitrate > 0 ? `${bitrate}kbps` : '-';
                    
                } catch (error) {
                    console.error('Stats error:', error);
                }
            }, 2000);
        }

        // Adicionar ICE candidate √† lista
        function addICECandidate(candidate) {
            const iceCandidatesDiv = document.getElementById('iceCandidates');
            const candidateDiv = document.createElement('div');
            candidateDiv.className = `ice-candidate ${candidate.type}`;
            candidateDiv.innerHTML = `
                <span class="candidate-type">${candidate.type}</span>
                <span class="candidate-info">${candidate.address || 'N/A'}:${candidate.port || 'N/A'}</span>
            `;
            iceCandidatesDiv.appendChild(candidateDiv);
        }

        // Testar microfone
        async function testMicrophone() {
            try {
                log('üé§ Testando microfone...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Criar contexto de √°udio para teste
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                let testDuration = 3000; // 3 segundos
                let maxVolume = 0;
                
                const testInterval = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const volume = sum / bufferLength;
                    maxVolume = Math.max(maxVolume, volume);
                    
                    testDuration -= 100;
                    
                    if (testDuration <= 0) {
                        clearInterval(testInterval);
                        stream.getTracks().forEach(track => track.stop());
                        
                        if (maxVolume > 10) {
                            log('‚úÖ Microfone funcionando corretamente!', 'success');
                        } else {
                            log('‚ö†Ô∏è Microfone muito baixo ou n√£o detectado', 'warning');
                        }
                    }
                }, 100);
                
                log('üîä Fale algo para testar o microfone (3 segundos)...', 'info');
                
            } catch (error) {
                log(`‚ùå Erro no teste do microfone: ${error.message}`, 'error');
            }
        }

        // Alternar mute
        function toggleMute(type) {
            if (!localStream) return;
            
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                const button = document.getElementById(type === 'doorman' ? 'muteDoorman' : 'muteResident');
                button.textContent = audioTrack.enabled ? 'üîá' : 'üîä';
                
                log(`${audioTrack.enabled ? 'üîä' : 'üîá'} ${type === 'doorman' ? 'Porteiro' : 'Morador'} ${audioTrack.enabled ? 'desmutado' : 'mutado'}`, 'info');
            }
        }

        // Parar teste WebRTC
        function stopWebRTCTest() {
            try {
                log('‚èπÔ∏è Parando teste WebRTC...', 'info');
                
                // Parar streams
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                    remoteStream = null;
                }
                
                // Fechar peer connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                // Parar contexto de √°udio
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                
                // Limpar intervalos
                if (volumeInterval) {
                    clearInterval(volumeInterval);
                    volumeInterval = null;
                }
                
                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                }
                
                // Resetar interface
                isWebRTCActive = false;
                document.getElementById('startWebRTCTest').disabled = false;
                document.getElementById('stopWebRTCTest').disabled = true;
                document.getElementById('audioControls').style.display = 'none';
                document.getElementById('residentAudioControls').style.display = 'none';
                document.getElementById('connectionStats').style.display = 'none';
                document.getElementById('iceCandidatesSection').style.display = 'none';
                
                // Limpar ICE candidates
                document.getElementById('iceCandidates').innerHTML = '';
                
                updateWebRTCStatus('disconnected', 'üî¥ Desconectado - Teste finalizado');
                log('‚úÖ Teste WebRTC finalizado', 'success');
                
            } catch (error) {
                log(`‚ùå Erro ao parar teste: ${error.message}`, 'error');
            }
        }

        // Atualizar status WebRTC
        function updateWebRTCStatus(status, message) {
            const statusElement = document.getElementById('webrtcStatus');
            statusElement.className = `connection-status ${status}`;
            statusElement.innerHTML = `<span>${status === 'connected' ? 'üü¢' : status === 'connecting' ? 'üü°' : 'üî¥'}</span><span>${message}</span>`;
        }

        // Inicializar quando a p√°gina carregar
        window.onload = initializeSystem;

        // Cleanup ao fechar a p√°gina
        window.onbeforeunload = function() {
            if (isWebRTCActive) {
                stopWebRTCTest();
            }
            console.log('Fechando sistema de interfone...');
        };
    </script>
</body>
</html>